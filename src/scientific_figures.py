"""
科研论文配图生成模块
Scientific Figure Generator for Geological Modeling

生成高质量、符合SCI期刊要求的地质建模配图。
支持 Matplotlib (高分辨率静态图) 和 Plotly (交互式图表)。

功能包括：
1. 三维地质模型渲染
2. 地层剖面图
3. 钻孔柱状图
4. 厚度等值线图
5. 建模流程图
6. 误差分析图
7. 统计图表

作者: Generated by Claude Code
日期: 2025-12-23
"""

import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from matplotlib.colors import LinearSegmentedColormap, Normalize
from matplotlib.patches import FancyBboxPatch, Rectangle, Polygon, Circle
from matplotlib.collections import PolyCollection
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
import matplotlib.gridspec as gridspec
from matplotlib import font_manager
from typing import Dict, List, Optional, Tuple, Any, Union
from dataclasses import dataclass
from datetime import datetime
import warnings

# 尝试导入plotly
try:
    import plotly.graph_objects as go
    import plotly.express as px
    from plotly.subplots import make_subplots
    HAS_PLOTLY = True
except ImportError:
    HAS_PLOTLY = False
    warnings.warn("Plotly not installed. Interactive figures will not be available.")

# 尝试设置中文字体
def setup_chinese_font():
    """设置中文字体支持"""
    # Windows 系统常用中文字体
    chinese_fonts = [
        'Microsoft YaHei', 'SimHei', 'SimSun', 'KaiTi',
        'FangSong', 'STSong', 'STHeiti', 'STKaiti',
        'NSimSun', 'DengXian', 'Microsoft JhengHei'
    ]

    # 尝试直接设置字体
    for font_name in chinese_fonts:
        try:
            # 检查字体是否可用
            font_list = [f.name for f in font_manager.fontManager.ttflist]
            if font_name in font_list:
                plt.rcParams['font.sans-serif'] = [font_name] + plt.rcParams.get('font.sans-serif', [])
                plt.rcParams['font.family'] = 'sans-serif'
                plt.rcParams['axes.unicode_minus'] = False
                print(f"使用中文字体: {font_name}")
                return font_name
        except Exception as e:
            continue

    # 如果没有找到中文字体，尝试使用系统默认
    try:
        plt.rcParams['font.sans-serif'] = ['Microsoft YaHei', 'SimHei', 'DejaVu Sans']
        plt.rcParams['axes.unicode_minus'] = False
        return 'Microsoft YaHei'
    except:
        pass

    # 最后的回退
    plt.rcParams['axes.unicode_minus'] = False
    return None


# 初始化字体
CHINESE_FONT = setup_chinese_font()


@dataclass
class FigureConfig:
    """图形配置"""
    # SCI期刊标准尺寸 (英寸)
    SINGLE_COLUMN = (3.35, 2.5)      # 单栏 85mm
    ONE_HALF_COLUMN = (5.0, 3.75)    # 1.5栏
    DOUBLE_COLUMN = (7.0, 5.0)       # 双栏 180mm
    FULL_PAGE = (7.0, 9.0)           # 整页

    # DPI设置
    SCREEN_DPI = 100
    PRINT_DPI = 300
    PUBLICATION_DPI = 600

    # 字体大小
    TITLE_SIZE = 12
    LABEL_SIZE = 10
    TICK_SIZE = 8
    LEGEND_SIZE = 8
    ANNOTATION_SIZE = 7


class GeologyColorScheme:
    """地质配色方案"""

    # 岩性颜色 (RGB 0-1)
    ROCK_COLORS = {
        'coal': (0.15, 0.15, 0.15),           # 煤 - 深灰黑
        'mudstone': (0.55, 0.47, 0.37),       # 泥岩 - 褐色
        'sandstone': (0.85, 0.75, 0.55),      # 砂岩 - 黄褐色
        'sandy_mudstone': (0.65, 0.55, 0.45), # 砂质泥岩
        'carbonaceous_mudstone': (0.35, 0.32, 0.28),  # 炭质泥岩
        'siltstone': (0.75, 0.68, 0.55),      # 粉砂岩
        'limestone': (0.70, 0.75, 0.80),      # 灰岩 - 浅蓝灰
        'shale': (0.50, 0.50, 0.55),          # 页岩
        'conglomerate': (0.80, 0.65, 0.50),   # 砾岩
        'default': (0.60, 0.60, 0.60),        # 默认
    }

    # 岩性填充图案 (matplotlib hatch)
    ROCK_HATCHES = {
        'coal': 'xxxx',
        'mudstone': '...',
        'sandstone': '///',
        'sandy_mudstone': './',
        'carbonaceous_mudstone': 'xx',
        'siltstone': '\\\\\\',
        'limestone': '+++',
        'shale': '---',
        'conglomerate': 'ooo',
        'default': '',
    }

    # 中文名称映射
    CHINESE_NAMES = {
        'coal': '煤层',
        'mudstone': '泥岩',
        'sandstone': '砂岩',
        'sandy_mudstone': '砂质泥岩',
        'carbonaceous_mudstone': '炭质泥岩',
        'siltstone': '粉砂岩',
        'limestone': '灰岩',
        'shale': '页岩',
        'conglomerate': '砾岩',
        'default': '未知',
    }

    # SCI论文常用配色
    SCI_COLORS = {
        'primary': '#E64B35',      # 红色
        'secondary': '#4DBBD5',    # 青色
        'tertiary': '#00A087',     # 绿色
        'quaternary': '#3C5488',   # 深蓝
        'quinary': '#F39B7F',      # 橙色
        'senary': '#8491B4',       # 灰蓝
        'septenary': '#91D1C2',    # 浅绿
        'octonary': '#DC0000',     # 深红
    }

    @classmethod
    def get_color(cls, rock_type: str) -> Tuple[float, float, float]:
        """获取岩性颜色"""
        # 处理煤层编号
        if rock_type.startswith('coal'):
            return cls.ROCK_COLORS['coal']
        return cls.ROCK_COLORS.get(rock_type, cls.ROCK_COLORS['default'])

    @classmethod
    def get_hatch(cls, rock_type: str) -> str:
        """获取岩性填充图案"""
        if rock_type.startswith('coal'):
            return cls.ROCK_HATCHES['coal']
        return cls.ROCK_HATCHES.get(rock_type, cls.ROCK_HATCHES['default'])

    @classmethod
    def get_chinese_name(cls, rock_type: str) -> str:
        """获取中文名称"""
        if rock_type.startswith('coal_'):
            coal_id = rock_type.replace('coal_', '')
            return f'{coal_id}煤'
        return cls.CHINESE_NAMES.get(rock_type, rock_type)


class ScientificFigureGenerator:
    """科研论文配图生成器"""

    def __init__(self, output_dir: str = './figures', dpi: int = 300):
        """
        初始化配图生成器

        Args:
            output_dir: 输出目录
            dpi: 图像分辨率
        """
        self.output_dir = output_dir
        self.dpi = dpi
        self.config = FigureConfig()
        self.colors = GeologyColorScheme()

        # 创建输出目录
        os.makedirs(output_dir, exist_ok=True)

        # 设置matplotlib全局样式
        self._setup_style()

    def _setup_style(self):
        """设置matplotlib全局样式"""
        plt.style.use('seaborn-v0_8-whitegrid')

        plt.rcParams.update({
            'figure.dpi': self.dpi,
            'savefig.dpi': self.dpi,
            'font.size': self.config.LABEL_SIZE,
            'axes.titlesize': self.config.TITLE_SIZE,
            'axes.labelsize': self.config.LABEL_SIZE,
            'xtick.labelsize': self.config.TICK_SIZE,
            'ytick.labelsize': self.config.TICK_SIZE,
            'legend.fontsize': self.config.LEGEND_SIZE,
            'figure.titlesize': self.config.TITLE_SIZE,
            'axes.linewidth': 0.8,
            'grid.linewidth': 0.5,
            'lines.linewidth': 1.0,
            'patch.linewidth': 0.5,
        })

    def save_figure(self, fig, filename: str, formats: List[str] = None,
                   transparent: bool = False) -> List[str]:
        """
        保存图形到多种格式

        Args:
            fig: matplotlib figure对象
            filename: 文件名（不含扩展名）
            formats: 输出格式列表，默认 ['png', 'pdf', 'svg']
            transparent: 是否透明背景

        Returns:
            保存的文件路径列表
        """
        if formats is None:
            formats = ['png', 'pdf', 'svg']

        saved_files = []
        for fmt in formats:
            filepath = os.path.join(self.output_dir, f'{filename}.{fmt}')
            fig.savefig(filepath, format=fmt, dpi=self.dpi,
                       bbox_inches='tight', transparent=transparent,
                       facecolor='white' if not transparent else 'none',
                       edgecolor='none')
            saved_files.append(filepath)
            print(f"  保存: {filepath}")

        return saved_files

    # =========================================================================
    # 1. 三维地质模型图
    # =========================================================================

    def plot_3d_geological_model(self, layers: List[Dict],
                                  title: str = "三维地质模型",
                                  view_angle: Tuple[float, float] = (25, -60),
                                  show_wireframe: bool = False,
                                  colorbar: bool = True,
                                  figsize: Tuple[float, float] = None) -> plt.Figure:
        """
        绘制三维地质模型

        Args:
            layers: 地层数据列表，每层包含 name, grid_x, grid_y, top_surface_z, bottom_surface_z
            title: 图标题
            view_angle: 视角 (elevation, azimuth)
            show_wireframe: 是否显示线框
            colorbar: 是否显示颜色条
            figsize: 图形大小

        Returns:
            matplotlib Figure对象
        """
        if figsize is None:
            figsize = self.config.DOUBLE_COLUMN

        fig = plt.figure(figsize=figsize)
        ax = fig.add_subplot(111, projection='3d')

        legend_patches = []

        for layer in layers:
            name = layer.get('name', 'Unknown')
            grid_x = np.asarray(layer['grid_x'])
            grid_y = np.asarray(layer['grid_y'])
            top_z = np.asarray(layer['top_surface_z'])
            bottom_z = np.asarray(layer['bottom_surface_z'])

            # 确保是2D网格
            if grid_x.ndim == 1:
                grid_x, grid_y = np.meshgrid(grid_x, grid_y)

            # 获取岩性类型和颜色
            is_coal = '煤' in name or 'coal' in name.lower()
            if is_coal:
                rock_type = 'coal'
            else:
                # 简单的岩性识别
                rock_type = 'default'
                for rt in ['mudstone', 'sandstone', 'siltstone', 'limestone', 'shale']:
                    if rt in name.lower():
                        rock_type = rt
                        break
                if '泥岩' in name:
                    rock_type = 'mudstone'
                elif '砂岩' in name:
                    rock_type = 'sandstone'
                elif '粉砂' in name:
                    rock_type = 'siltstone'

            color = self.colors.get_color(rock_type)

            # 绘制顶面
            ax.plot_surface(grid_x, grid_y, top_z,
                           color=color, alpha=0.85,
                           linewidth=0.3 if show_wireframe else 0,
                           edgecolor='gray' if show_wireframe else 'none',
                           antialiased=True)

            # 添加图例
            legend_patches.append(mpatches.Patch(color=color, label=name))

        # 设置坐标轴
        ax.set_xlabel('X (m)', fontsize=self.config.LABEL_SIZE)
        ax.set_ylabel('Y (m)', fontsize=self.config.LABEL_SIZE)
        ax.set_zlabel('Z (m)', fontsize=self.config.LABEL_SIZE)
        ax.set_title(title, fontsize=self.config.TITLE_SIZE, fontweight='bold')

        # 设置视角
        ax.view_init(elev=view_angle[0], azim=view_angle[1])

        # 添加图例
        ax.legend(handles=legend_patches, loc='upper left',
                 fontsize=self.config.LEGEND_SIZE, framealpha=0.9)

        # 等比例坐标轴
        self._set_axes_equal_3d(ax)

        plt.tight_layout()
        return fig

    def _set_axes_equal_3d(self, ax):
        """设置3D坐标轴等比例"""
        x_limits = ax.get_xlim3d()
        y_limits = ax.get_ylim3d()
        z_limits = ax.get_zlim3d()

        x_range = abs(x_limits[1] - x_limits[0])
        y_range = abs(y_limits[1] - y_limits[0])
        z_range = abs(z_limits[1] - z_limits[0])

        max_range = max(x_range, y_range, z_range)

        x_middle = np.mean(x_limits)
        y_middle = np.mean(y_limits)
        z_middle = np.mean(z_limits)

        ax.set_xlim3d([x_middle - max_range/2, x_middle + max_range/2])
        ax.set_ylim3d([y_middle - max_range/2, y_middle + max_range/2])
        ax.set_zlim3d([z_middle - max_range/2, z_middle + max_range/2])

    # =========================================================================
    # 2. 地层剖面图
    # =========================================================================

    def plot_cross_section(self, layers: List[Dict],
                           section_y: float = None,
                           title: str = "地层剖面图",
                           show_labels: bool = True,
                           show_hatch: bool = True,
                           figsize: Tuple[float, float] = None) -> plt.Figure:
        """
        绘制地层剖面图 (沿Y方向切一个X-Z剖面)

        Args:
            layers: 地层数据列表
            section_y: 剖面Y坐标，None则取中间位置
            title: 图标题
            show_labels: 是否显示地层标注
            show_hatch: 是否显示填充图案
            figsize: 图形大小

        Returns:
            matplotlib Figure对象
        """
        if figsize is None:
            figsize = self.config.DOUBLE_COLUMN

        fig, ax = plt.subplots(figsize=figsize)

        # 确定剖面位置
        first_layer = layers[0]
        grid_y = np.asarray(first_layer['grid_y'])
        if grid_y.ndim == 2:
            grid_y = grid_y[:, 0]

        if section_y is None:
            section_y = grid_y[len(grid_y)//2]

        # 找到最近的Y索引
        y_idx = np.argmin(np.abs(grid_y - section_y))

        legend_patches = []

        for layer in layers:
            name = layer.get('name', 'Unknown')
            grid_x = np.asarray(layer['grid_x'])
            top_z = np.asarray(layer['top_surface_z'])
            bottom_z = np.asarray(layer['bottom_surface_z'])

            if grid_x.ndim == 2:
                grid_x = grid_x[0, :]
            if top_z.ndim == 2:
                top_z = top_z[y_idx, :]
                bottom_z = bottom_z[y_idx, :]

            # 获取岩性
            is_coal = '煤' in name or 'coal' in name.lower()
            rock_type = 'coal' if is_coal else 'default'
            for rt in ['mudstone', 'sandstone', 'siltstone', 'limestone', 'shale',
                      'sandy_mudstone', 'carbonaceous_mudstone']:
                if rt in name.lower() or (rt == 'mudstone' and '泥岩' in name) or \
                   (rt == 'sandstone' and '砂岩' in name):
                    rock_type = rt
                    break

            color = self.colors.get_color(rock_type)
            hatch = self.colors.get_hatch(rock_type) if show_hatch else ''

            # 创建多边形
            vertices = []
            for i in range(len(grid_x)):
                vertices.append([grid_x[i], bottom_z[i]])
            for i in range(len(grid_x)-1, -1, -1):
                vertices.append([grid_x[i], top_z[i]])

            poly = Polygon(vertices, closed=True, facecolor=color,
                          edgecolor='black', linewidth=0.5,
                          hatch=hatch, alpha=0.9)
            ax.add_patch(poly)

            # 添加标注
            if show_labels:
                mid_x = np.mean(grid_x)
                mid_z = np.mean([np.mean(top_z), np.mean(bottom_z)])
                ax.annotate(name, (mid_x, mid_z), fontsize=self.config.ANNOTATION_SIZE,
                           ha='center', va='center',
                           bbox=dict(boxstyle='round,pad=0.2', facecolor='white',
                                    alpha=0.7, edgecolor='none'))

            legend_patches.append(mpatches.Patch(facecolor=color, edgecolor='black',
                                                 hatch=hatch, label=name))

        ax.set_xlabel('X (m)', fontsize=self.config.LABEL_SIZE)
        ax.set_ylabel('Z - 标高 (m)', fontsize=self.config.LABEL_SIZE)
        ax.set_title(f'{title} (Y = {section_y:.1f} m)',
                    fontsize=self.config.TITLE_SIZE, fontweight='bold')

        ax.autoscale()
        ax.set_aspect('auto')

        # 图例放在右侧
        ax.legend(handles=legend_patches, loc='center left',
                 bbox_to_anchor=(1.02, 0.5), fontsize=self.config.LEGEND_SIZE)

        plt.tight_layout()
        return fig

    # =========================================================================
    # 3. 钻孔柱状图
    # =========================================================================

    def plot_borehole_column(self, borehole_data: Dict,
                              title: str = None,
                              width: float = 1.5,
                              figsize: Tuple[float, float] = None) -> plt.Figure:
        """
        绘制单个钻孔柱状图

        Args:
            borehole_data: 钻孔数据字典，包含:
                - name: 钻孔名称
                - x, y: 坐标
                - layers: 地层列表 [{name, top_depth, bottom_depth, thickness}, ...]
            title: 图标题
            width: 柱状图宽度
            figsize: 图形大小

        Returns:
            matplotlib Figure对象
        """
        if figsize is None:
            figsize = (3, 8)

        fig, ax = plt.subplots(figsize=figsize)

        bh_name = borehole_data.get('name', 'BH')
        layers = borehole_data.get('layers', [])

        if title is None:
            title = f'钻孔柱状图 - {bh_name}'

        legend_patches = []

        for layer in layers:
            name = layer.get('name', 'Unknown')
            top = layer.get('top_depth', 0)
            bottom = layer.get('bottom_depth', top + 1)
            thickness = bottom - top

            # 获取岩性
            is_coal = '煤' in name or 'coal' in name.lower()
            rock_type = 'coal' if is_coal else 'default'
            for rt in ['mudstone', 'sandstone', 'siltstone', 'limestone', 'shale',
                      'sandy_mudstone', 'carbonaceous_mudstone']:
                if rt in name.lower() or (rt == 'mudstone' and '泥岩' in name):
                    rock_type = rt
                    break

            color = self.colors.get_color(rock_type)
            hatch = self.colors.get_hatch(rock_type)

            # 绘制地层矩形
            rect = Rectangle((0, -bottom), width, thickness,
                            facecolor=color, edgecolor='black',
                            linewidth=0.8, hatch=hatch)
            ax.add_patch(rect)

            # 地层名称标注
            mid_depth = -(top + bottom) / 2
            ax.text(width + 0.2, mid_depth, name,
                   fontsize=self.config.ANNOTATION_SIZE,
                   va='center', ha='left')

            # 厚度标注
            ax.text(width + 2.5, mid_depth, f'{thickness:.2f}m',
                   fontsize=self.config.ANNOTATION_SIZE,
                   va='center', ha='left')

            # 深度标注
            ax.text(-0.3, -top, f'{top:.1f}',
                   fontsize=self.config.TICK_SIZE,
                   va='center', ha='right')

            if layer == layers[-1]:
                ax.text(-0.3, -bottom, f'{bottom:.1f}',
                       fontsize=self.config.TICK_SIZE,
                       va='center', ha='right')

            legend_patches.append(mpatches.Patch(facecolor=color, edgecolor='black',
                                                 hatch=hatch, label=name))

        # 设置坐标轴
        ax.set_xlim(-1, width + 4)
        if layers:
            max_depth = max(l.get('bottom_depth', 0) for l in layers)
            ax.set_ylim(-max_depth * 1.05, 0.5)

        ax.set_ylabel('深度 (m)', fontsize=self.config.LABEL_SIZE)
        ax.set_title(title, fontsize=self.config.TITLE_SIZE, fontweight='bold')

        # 隐藏x轴
        ax.xaxis.set_visible(False)
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.spines['bottom'].set_visible(False)

        # 添加表头
        ax.text(width/2, 0.3, '岩性', fontsize=self.config.LABEL_SIZE,
               ha='center', fontweight='bold')
        ax.text(width + 1.5, 0.3, '地层', fontsize=self.config.LABEL_SIZE,
               ha='center', fontweight='bold')
        ax.text(width + 3, 0.3, '厚度', fontsize=self.config.LABEL_SIZE,
               ha='center', fontweight='bold')

        plt.tight_layout()
        return fig

    # =========================================================================
    # 4. 多钻孔对比图
    # =========================================================================

    def plot_borehole_correlation(self, boreholes: List[Dict],
                                   title: str = "钻孔地层对比图",
                                   spacing: float = 3.0,
                                   connect_layers: bool = True,
                                   figsize: Tuple[float, float] = None) -> plt.Figure:
        """
        绘制多钻孔地层对比图

        Args:
            boreholes: 钻孔数据列表
            title: 图标题
            spacing: 钻孔间距
            connect_layers: 是否连接相同地层
            figsize: 图形大小

        Returns:
            matplotlib Figure对象
        """
        n_boreholes = len(boreholes)
        if figsize is None:
            figsize = (2.5 * n_boreholes + 2, 8)

        fig, ax = plt.subplots(figsize=figsize)

        bh_width = 1.2
        all_depths = []

        # 绘制每个钻孔
        for idx, bh in enumerate(boreholes):
            x_offset = idx * spacing
            bh_name = bh.get('name', f'BH{idx+1}')
            layers = bh.get('layers', [])

            for layer in layers:
                name = layer.get('name', 'Unknown')
                top = layer.get('top_depth', 0)
                bottom = layer.get('bottom_depth', top + 1)
                all_depths.extend([top, bottom])

                # 获取颜色
                is_coal = '煤' in name or 'coal' in name.lower()
                rock_type = 'coal' if is_coal else 'default'
                for rt in ['mudstone', 'sandstone', 'siltstone']:
                    if rt in name.lower() or (rt == 'mudstone' and '泥岩' in name):
                        rock_type = rt
                        break

                color = self.colors.get_color(rock_type)
                hatch = self.colors.get_hatch(rock_type)

                rect = Rectangle((x_offset, -bottom), bh_width, bottom - top,
                                facecolor=color, edgecolor='black',
                                linewidth=0.6, hatch=hatch)
                ax.add_patch(rect)

            # 钻孔名称
            ax.text(x_offset + bh_width/2, 0.5, bh_name,
                   fontsize=self.config.LABEL_SIZE, ha='center', fontweight='bold')

        # 连接相同地层
        if connect_layers and n_boreholes > 1:
            layer_names = set()
            for bh in boreholes:
                for layer in bh.get('layers', []):
                    layer_names.add(layer.get('name', ''))

            for layer_name in layer_names:
                points_top = []
                points_bottom = []

                for idx, bh in enumerate(boreholes):
                    x_offset = idx * spacing
                    for layer in bh.get('layers', []):
                        if layer.get('name', '') == layer_name:
                            points_top.append((x_offset + bh_width, -layer['top_depth']))
                            points_bottom.append((x_offset, -layer['bottom_depth']))

                # 绘制连接线
                if len(points_top) > 1:
                    for i in range(len(points_top) - 1):
                        ax.plot([points_top[i][0], points_top[i+1][0] - bh_width + spacing],
                               [points_top[i][1], points_top[i+1][1]],
                               'k--', linewidth=0.5, alpha=0.5)

        # 设置坐标轴
        ax.set_xlim(-0.5, n_boreholes * spacing)
        if all_depths:
            ax.set_ylim(-max(all_depths) * 1.05, 1)

        ax.set_ylabel('深度 (m)', fontsize=self.config.LABEL_SIZE)
        ax.set_title(title, fontsize=self.config.TITLE_SIZE, fontweight='bold')
        ax.xaxis.set_visible(False)

        plt.tight_layout()
        return fig

    # =========================================================================
    # 5. 厚度等值线图
    # =========================================================================

    def plot_thickness_contour(self, grid_x: np.ndarray, grid_y: np.ndarray,
                                thickness: np.ndarray, layer_name: str = "地层",
                                title: str = None,
                                cmap: str = 'YlOrRd',
                                show_boreholes: bool = True,
                                borehole_coords: List[Tuple[float, float]] = None,
                                figsize: Tuple[float, float] = None) -> plt.Figure:
        """
        绘制地层厚度等值线图

        Args:
            grid_x, grid_y: 网格坐标
            thickness: 厚度数据
            layer_name: 地层名称
            title: 图标题
            cmap: 颜色映射
            show_boreholes: 是否显示钻孔位置
            borehole_coords: 钻孔坐标列表
            figsize: 图形大小

        Returns:
            matplotlib Figure对象
        """
        if figsize is None:
            figsize = self.config.DOUBLE_COLUMN

        if title is None:
            title = f'{layer_name}厚度等值线图'

        fig, ax = plt.subplots(figsize=figsize)

        # 绘制填充等值线
        if grid_x.ndim == 1:
            grid_x, grid_y = np.meshgrid(grid_x, grid_y)

        # 过滤NaN
        valid_mask = ~np.isnan(thickness)
        if not np.any(valid_mask):
            ax.text(0.5, 0.5, '无有效数据', ha='center', va='center',
                   transform=ax.transAxes, fontsize=14)
            return fig

        levels = np.linspace(np.nanmin(thickness), np.nanmax(thickness), 15)

        cf = ax.contourf(grid_x, grid_y, thickness, levels=levels,
                        cmap=cmap, extend='both')
        cs = ax.contour(grid_x, grid_y, thickness, levels=levels[::2],
                       colors='black', linewidths=0.5, alpha=0.5)
        ax.clabel(cs, inline=True, fontsize=self.config.TICK_SIZE, fmt='%.1f')

        # 颜色条
        cbar = plt.colorbar(cf, ax=ax, shrink=0.8, pad=0.02)
        cbar.set_label('厚度 (m)', fontsize=self.config.LABEL_SIZE)

        # 显示钻孔位置
        if show_boreholes and borehole_coords:
            bh_x = [c[0] for c in borehole_coords]
            bh_y = [c[1] for c in borehole_coords]
            ax.scatter(bh_x, bh_y, c='black', s=50, marker='^',
                      zorder=10, label='钻孔位置')
            ax.legend(loc='upper right', fontsize=self.config.LEGEND_SIZE)

        ax.set_xlabel('X (m)', fontsize=self.config.LABEL_SIZE)
        ax.set_ylabel('Y (m)', fontsize=self.config.LABEL_SIZE)
        ax.set_title(title, fontsize=self.config.TITLE_SIZE, fontweight='bold')
        ax.set_aspect('equal')

        plt.tight_layout()
        return fig

    # =========================================================================
    # 6. 模型统计图
    # =========================================================================

    def plot_layer_statistics(self, layers_info: List[Dict],
                               title: str = "地层统计",
                               figsize: Tuple[float, float] = None) -> plt.Figure:
        """
        绘制地层统计图（饼图+柱状图组合）

        Args:
            layers_info: 地层信息列表 [{name, volume, thickness_avg, zone_count}, ...]
            title: 图标题
            figsize: 图形大小

        Returns:
            matplotlib Figure对象
        """
        if figsize is None:
            figsize = (10, 4)

        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=figsize)

        names = [l.get('name', f'Layer{i}') for i, l in enumerate(layers_info)]
        volumes = [l.get('volume', 1) for l in layers_info]
        thicknesses = [l.get('thickness_avg', 1) for l in layers_info]

        # 获取颜色
        colors = []
        for name in names:
            is_coal = '煤' in name or 'coal' in name.lower()
            rock_type = 'coal' if is_coal else 'default'
            for rt in ['mudstone', 'sandstone', 'siltstone']:
                if rt in name.lower():
                    rock_type = rt
                    break
            colors.append(self.colors.get_color(rock_type))

        # 饼图 - 体积占比
        wedges, texts, autotexts = ax1.pie(volumes, labels=names, colors=colors,
                                           autopct='%1.1f%%', startangle=90,
                                           textprops={'fontsize': self.config.TICK_SIZE})
        ax1.set_title('体积占比', fontsize=self.config.LABEL_SIZE, fontweight='bold')

        # 柱状图 - 平均厚度
        x = np.arange(len(names))
        bars = ax2.bar(x, thicknesses, color=colors, edgecolor='black', linewidth=0.5)
        ax2.set_xticks(x)
        ax2.set_xticklabels(names, rotation=45, ha='right',
                          fontsize=self.config.TICK_SIZE)
        ax2.set_ylabel('平均厚度 (m)', fontsize=self.config.LABEL_SIZE)
        ax2.set_title('各层平均厚度', fontsize=self.config.LABEL_SIZE, fontweight='bold')

        # 在柱状图上添加数值
        for bar, val in zip(bars, thicknesses):
            ax2.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.1,
                    f'{val:.2f}', ha='center', va='bottom',
                    fontsize=self.config.ANNOTATION_SIZE)

        fig.suptitle(title, fontsize=self.config.TITLE_SIZE, fontweight='bold', y=1.02)
        plt.tight_layout()
        return fig

    # =========================================================================
    # 7. 建模流程图
    # =========================================================================

    def plot_modeling_workflow(self, title: str = "地质建模技术流程",
                                figsize: Tuple[float, float] = None) -> plt.Figure:
        """
        绘制建模流程图

        Args:
            title: 图标题
            figsize: 图形大小

        Returns:
            matplotlib Figure对象
        """
        if figsize is None:
            figsize = (12, 8)

        fig, ax = plt.subplots(figsize=figsize)
        ax.set_xlim(0, 12)
        ax.set_ylim(0, 8)
        ax.axis('off')

        # 定义流程框
        boxes = [
            # (x, y, width, height, text, color)
            (0.5, 6.5, 2, 1, '钻孔数据\n采集', '#E3F2FD'),
            (3.5, 6.5, 2, 1, '数据预处理\n质量控制', '#E8F5E9'),
            (6.5, 6.5, 2, 1, '地层划分\n岩性识别', '#FFF3E0'),
            (9.5, 6.5, 2, 1, '厚度计算\n统计分析', '#FCE4EC'),

            (0.5, 4, 2, 1, '空间插值\n(克里金/IDW)', '#E1F5FE'),
            (3.5, 4, 2, 1, 'GNN厚度\n预测', '#F3E5F5'),
            (6.5, 4, 2, 1, '三维模型\n构建', '#E0F7FA'),
            (9.5, 4, 2, 1, '模型验证\n精度评估', '#FBE9E7'),

            (3.5, 1.5, 2, 1, 'FLAC3D\n导出', '#ECEFF1'),
            (6.5, 1.5, 2, 1, '数值模拟\n分析', '#F5F5F5'),
        ]

        for (x, y, w, h, text, color) in boxes:
            box = FancyBboxPatch((x, y), w, h, boxstyle="round,pad=0.05,rounding_size=0.1",
                                facecolor=color, edgecolor='#333333', linewidth=1.5)
            ax.add_patch(box)
            ax.text(x + w/2, y + h/2, text, ha='center', va='center',
                   fontsize=9, fontweight='bold')

        # 绘制箭头
        arrows = [
            # 第一行
            ((2.5, 7), (3.5, 7)),
            ((5.5, 7), (6.5, 7)),
            ((8.5, 7), (9.5, 7)),
            # 向下
            ((1.5, 6.5), (1.5, 5)),
            ((4.5, 6.5), (4.5, 5)),
            ((7.5, 6.5), (7.5, 5)),
            ((10.5, 6.5), (10.5, 5)),
            # 第二行
            ((2.5, 4.5), (3.5, 4.5)),
            ((5.5, 4.5), (6.5, 4.5)),
            ((8.5, 4.5), (9.5, 4.5)),
            # 向下到第三行
            ((4.5, 4), (4.5, 2.5)),
            ((7.5, 4), (7.5, 2.5)),
            # 第三行
            ((5.5, 2), (6.5, 2)),
        ]

        for (start, end) in arrows:
            ax.annotate('', xy=end, xytext=start,
                       arrowprops=dict(arrowstyle='->', color='#666666', lw=1.5))

        ax.set_title(title, fontsize=14, fontweight='bold', y=0.98)

        plt.tight_layout()
        return fig

    # =========================================================================
    # 8. Plotly 交互式3D模型
    # =========================================================================

    def plot_3d_interactive(self, layers: List[Dict],
                            title: str = "交互式三维地质模型",
                            opacity: float = 0.85) -> 'go.Figure':
        """
        生成Plotly交互式3D地质模型

        Args:
            layers: 地层数据列表
            title: 图标题
            opacity: 透明度

        Returns:
            Plotly Figure对象
        """
        if not HAS_PLOTLY:
            raise ImportError("Plotly is required for interactive figures")

        fig = go.Figure()

        for layer in layers:
            name = layer.get('name', 'Unknown')
            grid_x = np.asarray(layer['grid_x'])
            grid_y = np.asarray(layer['grid_y'])
            top_z = np.asarray(layer['top_surface_z'])

            if grid_x.ndim == 1:
                grid_x, grid_y = np.meshgrid(grid_x, grid_y)

            # 获取颜色
            is_coal = '煤' in name or 'coal' in name.lower()
            rock_type = 'coal' if is_coal else 'default'
            for rt in ['mudstone', 'sandstone', 'siltstone']:
                if rt in name.lower():
                    rock_type = rt
                    break

            color = self.colors.get_color(rock_type)
            color_str = f'rgb({int(color[0]*255)},{int(color[1]*255)},{int(color[2]*255)})'

            # 添加表面
            fig.add_trace(go.Surface(
                x=grid_x, y=grid_y, z=top_z,
                name=name,
                colorscale=[[0, color_str], [1, color_str]],
                showscale=False,
                opacity=opacity,
                hovertemplate=f'{name}<br>X: %{{x:.1f}}<br>Y: %{{y:.1f}}<br>Z: %{{z:.1f}}<extra></extra>'
            ))

        fig.update_layout(
            title=dict(text=title, font=dict(size=16)),
            scene=dict(
                xaxis_title='X (m)',
                yaxis_title='Y (m)',
                zaxis_title='Z (m)',
                aspectmode='data'
            ),
            margin=dict(l=0, r=0, t=40, b=0),
            legend=dict(yanchor="top", y=0.99, xanchor="left", x=0.01)
        )

        return fig

    # =========================================================================
    # 9. 误差分析图
    # =========================================================================

    def plot_error_analysis(self, true_values: np.ndarray,
                            predicted_values: np.ndarray,
                            title: str = "预测误差分析",
                            figsize: Tuple[float, float] = None) -> plt.Figure:
        """
        绘制预测误差分析图（散点图+残差分布）

        Args:
            true_values: 真实值
            predicted_values: 预测值
            title: 图标题
            figsize: 图形大小

        Returns:
            matplotlib Figure对象
        """
        if figsize is None:
            figsize = (10, 4)

        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=figsize)

        # 计算误差
        errors = predicted_values - true_values
        mae = np.mean(np.abs(errors))
        rmse = np.sqrt(np.mean(errors**2))
        r2 = 1 - np.sum(errors**2) / np.sum((true_values - np.mean(true_values))**2)

        # 散点图
        ax1.scatter(true_values, predicted_values, alpha=0.6, s=30,
                   c=self.colors.SCI_COLORS['primary'], edgecolors='none')

        # 1:1线
        min_val = min(true_values.min(), predicted_values.min())
        max_val = max(true_values.max(), predicted_values.max())
        ax1.plot([min_val, max_val], [min_val, max_val], 'k--', lw=1.5, label='1:1 线')

        # 添加统计信息
        textstr = f'MAE = {mae:.3f}\nRMSE = {rmse:.3f}\nR² = {r2:.3f}'
        ax1.text(0.05, 0.95, textstr, transform=ax1.transAxes,
                fontsize=self.config.LEGEND_SIZE, verticalalignment='top',
                bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))

        ax1.set_xlabel('实测值', fontsize=self.config.LABEL_SIZE)
        ax1.set_ylabel('预测值', fontsize=self.config.LABEL_SIZE)
        ax1.set_title('预测值 vs 实测值', fontsize=self.config.LABEL_SIZE)
        ax1.legend(loc='lower right', fontsize=self.config.LEGEND_SIZE)
        ax1.set_aspect('equal')

        # 残差直方图
        ax2.hist(errors, bins=30, color=self.colors.SCI_COLORS['secondary'],
                edgecolor='white', alpha=0.8, density=True)
        ax2.axvline(x=0, color='red', linestyle='--', lw=1.5)
        ax2.set_xlabel('残差 (预测 - 实测)', fontsize=self.config.LABEL_SIZE)
        ax2.set_ylabel('频率密度', fontsize=self.config.LABEL_SIZE)
        ax2.set_title('残差分布', fontsize=self.config.LABEL_SIZE)

        fig.suptitle(title, fontsize=self.config.TITLE_SIZE, fontweight='bold', y=1.02)
        plt.tight_layout()
        return fig

    # =========================================================================
    # 10. 综合报告图
    # =========================================================================

    def plot_model_summary(self, model_info: Dict,
                           title: str = "地质模型综合报告",
                           figsize: Tuple[float, float] = None) -> plt.Figure:
        """
        绘制模型综合报告图

        Args:
            model_info: 模型信息字典，包含:
                - coord_range: 坐标范围
                - layer_count: 地层数量
                - zone_count: 单元数
                - layers_info: 各层信息列表
            title: 图标题
            figsize: 图形大小

        Returns:
            matplotlib Figure对象
        """
        if figsize is None:
            figsize = (12, 8)

        fig = plt.figure(figsize=figsize)
        gs = gridspec.GridSpec(2, 3, figure=fig, hspace=0.3, wspace=0.3)

        # 1. 模型基本信息表格
        ax1 = fig.add_subplot(gs[0, 0])
        ax1.axis('off')

        info_text = [
            ['参数', '值'],
            ['X范围', f"{model_info.get('x_min', 0):.1f} ~ {model_info.get('x_max', 0):.1f} m"],
            ['Y范围', f"{model_info.get('y_min', 0):.1f} ~ {model_info.get('y_max', 0):.1f} m"],
            ['Z范围', f"{model_info.get('z_min', 0):.1f} ~ {model_info.get('z_max', 0):.1f} m"],
            ['地层数', str(model_info.get('layer_count', 0))],
            ['单元数', f"{model_info.get('zone_count', 0):,}"],
            ['节点数', f"{model_info.get('node_count', 0):,}"],
        ]

        table = ax1.table(cellText=info_text[1:], colLabels=info_text[0],
                         loc='center', cellLoc='center',
                         colWidths=[0.4, 0.6])
        table.auto_set_font_size(False)
        table.set_fontsize(self.config.TICK_SIZE)
        table.scale(1, 1.5)
        ax1.set_title('模型基本参数', fontsize=self.config.LABEL_SIZE, fontweight='bold')

        # 2. 地层厚度柱状图
        ax2 = fig.add_subplot(gs[0, 1:])
        layers_info = model_info.get('layers_info', [])
        if layers_info:
            names = [l.get('name', '')[:10] for l in layers_info]
            thicknesses = [l.get('thickness_avg', 0) for l in layers_info]
            colors = []
            for name in [l.get('name', '') for l in layers_info]:
                is_coal = '煤' in name or 'coal' in name.lower()
                rock_type = 'coal' if is_coal else 'sandstone'
                colors.append(self.colors.get_color(rock_type))

            bars = ax2.barh(names, thicknesses, color=colors, edgecolor='black', linewidth=0.5)
            ax2.set_xlabel('平均厚度 (m)', fontsize=self.config.LABEL_SIZE)
            ax2.set_title('各地层平均厚度', fontsize=self.config.LABEL_SIZE, fontweight='bold')

            for bar, val in zip(bars, thicknesses):
                ax2.text(val + 0.1, bar.get_y() + bar.get_height()/2,
                        f'{val:.2f}', va='center', fontsize=self.config.ANNOTATION_SIZE)

        # 3. 体积占比饼图
        ax3 = fig.add_subplot(gs[1, 0])
        if layers_info:
            volumes = [l.get('volume', l.get('zone_count', 1)) for l in layers_info]
            colors = []
            for name in [l.get('name', '') for l in layers_info]:
                is_coal = '煤' in name or 'coal' in name.lower()
                rock_type = 'coal' if is_coal else 'sandstone'
                colors.append(self.colors.get_color(rock_type))

            ax3.pie(volumes, labels=names, colors=colors, autopct='%1.1f%%',
                   textprops={'fontsize': self.config.TICK_SIZE})
            ax3.set_title('体积占比', fontsize=self.config.LABEL_SIZE, fontweight='bold')

        # 4. 地层柱状简图
        ax4 = fig.add_subplot(gs[1, 1])
        if layers_info:
            current_depth = 0
            for i, layer in enumerate(layers_info):
                name = layer.get('name', '')
                thickness = layer.get('thickness_avg', 1)

                is_coal = '煤' in name or 'coal' in name.lower()
                rock_type = 'coal' if is_coal else 'sandstone'
                color = self.colors.get_color(rock_type)
                hatch = self.colors.get_hatch(rock_type)

                rect = Rectangle((0, -current_depth - thickness), 1, thickness,
                                facecolor=color, edgecolor='black',
                                linewidth=0.5, hatch=hatch)
                ax4.add_patch(rect)
                ax4.text(1.1, -current_depth - thickness/2, f'{name[:8]}',
                        fontsize=self.config.ANNOTATION_SIZE, va='center')
                current_depth += thickness

            ax4.set_xlim(-0.2, 2.5)
            ax4.set_ylim(-current_depth * 1.1, 0.5)
            ax4.set_ylabel('相对深度', fontsize=self.config.LABEL_SIZE)
            ax4.set_title('地层序列', fontsize=self.config.LABEL_SIZE, fontweight='bold')
            ax4.xaxis.set_visible(False)

        # 5. 生成时间戳
        ax5 = fig.add_subplot(gs[1, 2])
        ax5.axis('off')
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        ax5.text(0.5, 0.5, f'生成时间:\n{timestamp}',
                ha='center', va='center', fontsize=self.config.LABEL_SIZE,
                bbox=dict(boxstyle='round', facecolor='lightgray', alpha=0.3))

        fig.suptitle(title, fontsize=self.config.TITLE_SIZE + 2, fontweight='bold', y=0.98)

        return fig


# ============================================================================
# 便捷函数
# ============================================================================

def generate_all_figures(layers: List[Dict], output_dir: str = './figures',
                        model_info: Dict = None) -> Dict[str, str]:
    """
    一键生成所有科研配图

    Args:
        layers: 地层数据列表
        output_dir: 输出目录
        model_info: 模型信息

    Returns:
        生成的文件路径字典
    """
    generator = ScientificFigureGenerator(output_dir=output_dir, dpi=300)
    saved_files = {}

    print("=" * 60)
    print("科研论文配图生成")
    print("=" * 60)

    # 1. 三维地质模型
    print("\n[1/6] 生成三维地质模型图...")
    fig = generator.plot_3d_geological_model(layers, title="三维地质模型")
    files = generator.save_figure(fig, '3d_geological_model')
    saved_files['3d_model'] = files
    plt.close(fig)

    # 2. 剖面图
    print("\n[2/6] 生成地层剖面图...")
    fig = generator.plot_cross_section(layers, title="地层剖面图")
    files = generator.save_figure(fig, 'cross_section')
    saved_files['cross_section'] = files
    plt.close(fig)

    # 3. 建模流程图
    print("\n[3/6] 生成建模流程图...")
    fig = generator.plot_modeling_workflow()
    files = generator.save_figure(fig, 'modeling_workflow')
    saved_files['workflow'] = files
    plt.close(fig)

    # 4. 地层统计
    if model_info and 'layers_info' in model_info:
        print("\n[4/6] 生成地层统计图...")
        fig = generator.plot_layer_statistics(model_info['layers_info'])
        files = generator.save_figure(fig, 'layer_statistics')
        saved_files['statistics'] = files
        plt.close(fig)

    # 5. 综合报告
    if model_info:
        print("\n[5/6] 生成综合报告图...")
        fig = generator.plot_model_summary(model_info)
        files = generator.save_figure(fig, 'model_summary')
        saved_files['summary'] = files
        plt.close(fig)

    # 6. 交互式3D (Plotly)
    if HAS_PLOTLY:
        print("\n[6/6] 生成交互式3D模型...")
        fig_plotly = generator.plot_3d_interactive(layers)
        html_path = os.path.join(output_dir, '3d_interactive.html')
        fig_plotly.write_html(html_path)
        saved_files['interactive_3d'] = [html_path]
        print(f"  保存: {html_path}")

    print("\n" + "=" * 60)
    print(f"所有配图已保存到: {output_dir}")
    print("=" * 60)

    return saved_files


# ============================================================================
# 测试代码
# ============================================================================

if __name__ == '__main__':
    # 创建测试数据
    nx, ny = 20, 20
    x = np.linspace(0, 500, nx)
    y = np.linspace(0, 400, ny)
    XI, YI = np.meshgrid(x, y)

    base_z = -200 + 0.05 * XI + 0.03 * YI + 5 * np.sin(XI/100) * np.cos(YI/80)

    test_layers = [
        {
            'name': '泥岩_1',
            'grid_x': x, 'grid_y': y,
            'top_surface_z': base_z + 10,
            'bottom_surface_z': base_z,
        },
        {
            'name': '16-3煤',
            'grid_x': x, 'grid_y': y,
            'top_surface_z': base_z + 14,
            'bottom_surface_z': base_z + 10,
        },
        {
            'name': '砂岩_1',
            'grid_x': x, 'grid_y': y,
            'top_surface_z': base_z + 30,
            'bottom_surface_z': base_z + 14,
        },
        {
            'name': '16-2煤',
            'grid_x': x, 'grid_y': y,
            'top_surface_z': base_z + 34,
            'bottom_surface_z': base_z + 30,
        },
        {
            'name': '砂质泥岩_1',
            'grid_x': x, 'grid_y': y,
            'top_surface_z': base_z + 50,
            'bottom_surface_z': base_z + 34,
        },
    ]

    # 模型信息
    test_model_info = {
        'x_min': 0, 'x_max': 500,
        'y_min': 0, 'y_max': 400,
        'z_min': -200, 'z_max': -150,
        'layer_count': 5,
        'zone_count': 12500,
        'node_count': 15000,
        'layers_info': [
            {'name': '泥岩_1', 'thickness_avg': 10, 'zone_count': 2500},
            {'name': '16-3煤', 'thickness_avg': 4, 'zone_count': 2500},
            {'name': '砂岩_1', 'thickness_avg': 16, 'zone_count': 2500},
            {'name': '16-2煤', 'thickness_avg': 4, 'zone_count': 2500},
            {'name': '砂质泥岩_1', 'thickness_avg': 16, 'zone_count': 2500},
        ]
    }

    # 生成所有配图
    generate_all_figures(test_layers, output_dir='./test_figures', model_info=test_model_info)
