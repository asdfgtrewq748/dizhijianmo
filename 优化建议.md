下面给出**逐个文件的修改清单（按你当前代码结构来落地）**。我会把“准确率低”和“只预测两层、其余全 0”的根因，直接落实到每一步改哪里、加什么字段、怎么验收。

---

## 先明确一个高概率“全 0”根因（必须优先处理）

你当前的数据预处理里，`standardize_lithology()` 默认会把所有煤层合并成“煤”（`merge_coal=True`），并且 `process()` 里直接调用了默认行为。 
如果你的 `layer_order` 里是“9煤、12煤…”这种**分煤层**命名，那么合并后这些层在训练标签里会“查不到”，就会被当作缺失层→厚度填 0（模型自然学成只剩少数层非零）。

**结论：厚度预测任务必须禁用 merge_coal，并保证 layer_order 与 lithology 命名完全一致。**

---

# 1) `data_loader.py` 修改清单（核心：把“采样点分类数据”升级成“钻孔节点厚度回归数据”）

> 你现在的 `process()` 主要在做“样本点（沿孔深采样）→岩性分类”的 PyG Data；厚度预测需要的是“每个钻孔一个节点 → 输出 N 层厚度向量”。文档里也给了厚度数据集构建思路与字段要求（`borehole_id/x/y/layer_thickness/layer_order` 等）。 

### A. 新增：厚度任务的数据入口（不要复用“采样点 DataFrame”直接 sum）

你的文档示例 `build_thickness_dataset()` 对 `layer_thickness` 用了 `.sum()`。
但你当前 `load_single_borehole()` 会按 `sample_interval` 在同一层内生成多条采样点（每条都带同一个 `layer_thickness`），如果直接 sum 会把厚度乘以采样点数量，标签会被放大，训练会崩。

**改法（两选一，推荐 1）：**

1. **推荐：新增“返回层表”的 loader**

* [ ] 新增函数：`load_single_borehole_layers(file_path) -> df_layers`

  * 直接读取原始层序表（每层一行），包含 `borehole_id,x,y,lithology,layer_order,layer_thickness,top_depth,bottom_depth`
  * 这里的 `top_depth/bottom_depth` 你已经在 `load_single_borehole()` 里按累计厚度算过（同逻辑复用即可）。
* [ ] 保留旧的 `load_single_borehole()` 给岩性分类用（不破坏现有功能）。

2. **备选：从采样点 df 还原层表（务必去重）**

* [ ] `df_layers = df_samples.groupby(['borehole_id','layer_order','lithology'], as_index=False)['layer_thickness'].first()`
* [ ] 绝对不要用 sum（除非你能证明同一层被拆成多段且需要合并）。

### B. 新增：厚度专用 `process_thickness()`（与现有 `process()` 并行，不互相污染）

在 `BoreholeDataProcessor` 里新增一个方法，不要硬改现有 `process()`，避免你现在岩性分类还能跑。

* [ ] 新增方法：`process_thickness(self, df_layers, layer_order=None, merge_coal=False, ...) -> Dict`

  * **必须**：调用 `standardize_lithology(df, merge_coal=False, ...)`（厚度任务禁用煤层合并）。
  * `layer_order`：

    * [ ] 若外部传入就严格使用；
    * [ ] 否则按 `layer_order` 字段（数值）从深到浅推断并生成 `layer_name_list`（文档里也有 `_infer_layer_order` 思路）。

### C. 构建厚度标签：同时输出 3 个张量（解决“全 0”与缺失层）

对每个钻孔节点，构建：

* `y_thick`: `[num_boreholes, num_layers]` 连续厚度
* `y_exist`: `[num_boreholes, num_layers]` 是否存在（0/1）
* `y_mask`: `[num_boreholes, num_layers]` 是否“有可靠监督”（0/1）

具体步骤：

* [ ] 对每个 `bh_id`：

  * [ ] 取该孔坐标 `x,y`（文档示例也是按孔取坐标）。
  * [ ] 逐层遍历 `layer_order`：

    * 若该层在该孔出现：`thickness = ...`（来自层表的 layer_thickness）

      * `y_exist=1, y_mask=1`
    * 若该层没出现：不要直接当作“真实 0”

      * `y_exist=0`
      * `y_mask=0`（关键：**不把“缺测”当 0 监督**，否则模型会被零样本淹没）
* [ ] 额外保留一个 `layer_stats`：每层 `exist_rate`、非零样本数，用于 loss 权重。

> 这一步是专门为你“只剩两层非零”设计的：如果大多数层在多数孔里都被当作 0 监督，模型最优策略就是全预测 0。

### D. 节点特征：用“钻孔级特征”，不要掺入目标泄漏

你当前分类 `process()` 会自动选择数值列作为特征并做 scaler。
厚度任务建议明确指定特征列，避免把 `layer_thickness` 这类信息混进去。

* [ ] `X_node` 至少包含：`x,y` +（可选）`surface_z,total_depth`
* [ ] 如果你有其它测井/地质属性列（密度、孔隙度等），做钻孔级聚合（mean/max/std）后拼到节点特征。
* [ ] 标准化：为 thickness 任务单独维护 scaler（不要复用分类任务 scaler）。

### E. 图构建：钻孔节点 KNN 图继续用，但把 edge_attr 明确化

你分类训练里模型会在 `forward` 时尝试传 `edge_weight`。
厚度任务建议统一为 `edge_attr`（shape `[E,1]`）以便 GATv2/TransformerConv 使用。

* [ ] 在 `process_thickness()` 里：

  * [ ] `edge_index, edge_attr = self.build_graph(coords_xy, ...)`
  * [ ] `data.edge_attr = edge_attr`（float, `[E,1]`）
  * [ ] 如需兼容旧模型，也可同时保留 `data.edge_weight = edge_attr.squeeze()`。

### F. 数据划分：小样本（~20 孔）不要随机一次切完

* [ ] 增加 `split_mode`：

  * `random`（保留）
  * `kfold`（建议默认）
  * `spatial_block`（SCI 更有说服力：空间泛化）
* [ ] `process_thickness()` 返回 `fold_indices`（便于 trainer 循环训练多折）。

### G. 验收输出（你每次改完立刻看这 4 个 print）

* [ ] 打印每层 `exist_count` 与 `exist_rate`
* [ ] 打印 `y_mask.sum(dim=0)`，确认不是多数层全 0
* [ ] 随机抽 3 个孔：打印 `y_thick/y_exist/y_mask`
* [ ] 若发现某些层 `exist_count==0`：这层必须从 `layer_order` 移除或补数据，否则必然学成 0

---

# 2) `models.py` 修改清单（核心：新增“厚度回归模型”，并做“存在性+厚度”双头）

你的文档已经明确建议新增 `GNNThicknessPredictor`，并用 Softplus 保证非负输出，同时规划了 `models.py / trainer.py / src/layer_modeling.py` 的结构。

### A. 统一入口：确保 `get_thickness_model()` 真正可用

你现在的 `models.py` 里主要是分类网络（GCN/GraphSAGE/GAT/Transformer 等）。
按文档规划，厚度模型可以：

* [ ] 方案 1：直接在 `models.py` 里新增 `GNNThicknessPredictor`（最省事）
* [ ] 方案 2：新增 `src/layer_modeling.py`，然后在 `models.py` 里 import（按文档结构更清晰）。

### B. 厚度模型结构：必须做 4 个改动（对应你“全 0”与欠拟合）

1. **输出非负**：最后一层 `Softplus()`（文档也这么写）
2. **避免 ReLU 死亡**：回归头激活改 `LeakyReLU/GELU`（防止大量输出被压成 0）
3. **残差/LayerNorm**：分类模型里你已经大量用了残差与 LayerNorm（例如 GeoGCN/GeoGraphSAGE/Transformer 都有）。 
   厚度编码器同样加，防止层数一深就学不动。
4. **双头输出（强烈建议）**：

   * head1：`exist_logits`（每层是否存在，BCE）
   * head2：`thickness`（仅对存在层学回归，Huber/MSE）

这一步是“解决数据极度偏零”的关键工程化手段。

### C. 与边权重对齐：优先用支持 `edge_attr` 的卷积

你现有分类模型里已经有 `GATv2Conv`、`TransformerConv(edge_dim=1)` 的用法。
厚度模型建议：

* [ ] 若要用边的距离权重：选 `GATv2Conv(..., edge_dim=1)` 或 `TransformerConv(..., edge_dim=1)`
* [ ] `forward(x, edge_index, edge_attr)`，不要再混用 `edge_weight` / `edge_attr`。

### D. 验收点

* [ ] 随机输入一批节点：检查输出 `thickness.min() >= 0`
* [ ] 检查 `exist_prob` 的分布不是全 0.5 / 全 0
* [ ] 单层 overfit 测试：只训练某一层厚度，确认能把训练 MAE 拉到很低（否则架构/数据仍有问题）

---

# 3) `trainer.py` 修改清单（核心：从“分类训练器”扩展出“回归训练器”，并改 scheduler/early-stop 监控目标）

你现在的 `GeoModelTrainer` 完整围绕分类：`Focal/CrossEntropy`、`val_acc/val_f1`、并用 `val_acc` 保存最佳模型。 

厚度任务必须新增一个并行 trainer（建议叫 `ThicknessTrainer`，文档也这么规划）。

### A. 新增：`ThicknessLoss`（按“分层权重 + 约束项”落地）

文档已经给了 `ThicknessLoss` 的设计方向（不同层权重、总厚度约束等）。
你要在代码里落实成**可调的 loss 组合**：

* [ ] `loss_exist = BCEWithLogitsLoss(pos_weight=...)`（解决存在性极度不平衡）
* [ ] `loss_thick = SmoothL1Loss(reduction='none')`（或 MSE）

  * 只在 `y_mask==1` 的位置计算
  * 对存在层再乘一层 `layer_weights`（非零样本越少权重越高）
* [ ] `loss_total = |sum(pred_thick*exist_prob) - sum(true_thick)|`（可选，但对“层间分配”很有效）
* [ ] `loss = a*loss_exist + b*loss_thick + c*loss_total`（a/b/c 配置化）

### B. 新增：`ThicknessTrainer`（不要污染 GeoModelTrainer）

照着你现有 `GeoModelTrainer` 的结构复制一份最稳：设备/优化器/日志/EMA 都能复用。

关键必须改的点：

1. **scheduler 监控目标**

* 分类训练你会展示 `val_acc` 并据此保存最佳模型。
* 厚度训练必须：

  * [ ] `best_val_loss` 越小越好（保存依据改成 val_loss 或 val_mae）
  * [ ] `ReduceLROnPlateau(mode='min')`，`scheduler.step(val_loss)`（不要再按 acc）

2. **评价指标改为回归 + 存在性**

* [ ] overall MAE / RMSE
* [ ] per-layer MAE（必须打印，否则你还是会“只学两层”）
* [ ] existence precision/recall（存在层的召回率很关键）
* [ ] “预测为 0 的比例”（按层输出）

3. **早停依据**
   你现在的早停是基于 `val_loss` 的下降判断，但“最佳模型保存”还是按 `val_acc`。
   厚度训练器统一成：

* [ ] early-stop & best-model 都按 `val_loss` 或 `val_mae`

### C. 训练策略（对你这种小数据很关键）

* [ ] 默认开启 KFold（在 data_loader 返回 fold 后，trainer 里循环训练并汇总均值±方差）
* [ ] 把“每层的训练非零样本数”写入日志，训练中动态调 `layer_weights`（至少先静态按频次倒数）

### D. 验收点（你每次训练必须输出这些）

* [ ] 每层 `val_mae`（表格）
* [ ] 每层 `exist_recall`
* [ ] `pred_thick.mean(dim=0)` 与 `true_thick.mean(dim=0)` 对比（看是否又塌成 0）
* [ ] 抽 3 个孔：打印预测厚度向量与真实向量（肉眼一看就知道是不是只剩两层）

---

# 4)（建议新增）`src/layer_modeling.py` 修改清单（如果你要按文档的“层序累加建模”走）

你的文档已经规划了这个文件，并把“逐层累加生成曲面/体素化”的主类放这里。
如果你现在“只能建出一两层，其余缺数据”，那通常是**预测厚度向量本身就大量为 0/缺测**或**层序推断/命名对不上**，这个文件应负责：

* [ ] 明确 `layer_order`（从深到浅）并固化到元数据（训练/推理必须一致）
* [ ] 对每层厚度预测结果做：

  * `thickness = thickness * exist_prob`（避免不存在层产生伪厚度）
  * 对缺测层使用插值备份（`rbf/idw`）以保证模型能“建全层”
* [ ] 输出每层曲面 `bottom/top/thickness` 的字典结构（文档已有）。

---

## 最后给你一个执行顺序（按优先级最短路径排）

**P0（今天就能显著改善“全 0”）**

1. `data_loader.py`：厚度任务禁用 `merge_coal`，并对齐 layer 命名与 `layer_order`
2. `data_loader.py`：厚度标签改成 `y_thick + y_exist + y_mask`（不要把缺测当 0 监督）
3. `models.py`：回归头 `Softplus + LeakyReLU`，最好加“存在性+厚度”双头
4. `trainer.py`：新建 `ThicknessTrainer`，保存/早停/调度全部改为监控 `val_loss/val_mae`

**P1（为 SCI 的方法可信度加分）**
5) KFold / 空间 block 验证
6) 分层 MAE + 存在性召回率作为主指标
7) 层序累加建模（`layer_modeling.py`）与插值法对比实验

---

如果你愿意继续往下推进：你把**你实际的 `layer_order` 列表**（按深→浅）和一份**原始钻孔层表 CSV 的表头/样例 10 行**贴出来，我可以直接按你字段把 `process_thickness()` 的“标签构建与 mask 规则”写到可以复制进项目的程度（同时保证不破坏你现有的岩性分类训练链路）。
